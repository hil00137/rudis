
/******************** END GENERATED PYCRC FUNCTIONS ********************/

/* Initializes the 16KB lookup tables. */
use std::sync::Mutex;
use lazy_static::lazy_static;
use crate::crcspeed::crcspeed64native_init;

lazy_static! {
    static ref CRC64_TABLE: Mutex<[[u64; 256]; 8]> = Mutex::new([[0; 256]; 8]);
}
const POLY: u64 = 0xad93d23594c935a9;
/******************** BEGIN GENERATED PYCRC FUNCTIONS ********************/
/**
 * Generated on Sun Dec 21 14:14:07 2014,
 * by pycrc v0.8.2, https://www.tty1.net/pycrc/
 *
 * LICENSE ON GENERATED CODE:
 * ==========================
 * As of version 0.6, pycrc is released under the terms of the MIT licence.
 * The code generated by pycrc is not considered a substantial portion of the
 * software, therefore the author of pycrc will not claim any copyright on
 * the generated code.
 * ==========================
 *
 * CRC configuration:
 *    Width        = 64
 *    Poly         = 0xad93d23594c935a9
 *    XorIn        = 0xffffffffffffffff
 *    ReflectIn    = True
 *    XorOut       = 0x0000000000000000
 *    ReflectOut   = True
 *    Algorithm    = bit-by-bit-fast
 *
 * Modifications after generation (by matt):
 *   - included finalize step in-line with update for single-call generation
 *   - re-worked some inner variable architectures
 *   - adjusted function parameters to match expected prototypes.
 *****************************************************************************/

/**
 * Reflect all bits of a \a data word of \a data_len bytes.
 *
 * \param data         The data word to be reflected.
 * \param data_len     The width of \a data expressed in number of bits.
 * \return             The reflected data.
 *****************************************************************************/
fn crc_reflect(mut data: u64, data_len: usize) -> u64 {
    let mut ret: u64 = data & 0x01;
    for _i in 1 .. data_len {
        data >>= 1;
        ret = (ret << 1) | (data & 0x01);
    }
    return ret;
}

/**
 *  Update the crc value with new data.
 *
 * \param crc      The current crc value.
 * \param data     Pointer to a buffer of \a data_len bytes.
 * \param data_len Number of bytes in the \a data buffer.
 * \return         The updated crc value.
 ******************************************************************************/
fn _crc64(mut crc: u64, in_data: &u8, len: u64) -> u64 {
    let data: &u8 = in_data;
    let mut bit: u64 = 0;

    for offset in 0 .. len {
        let c = (data >> offset) & 1;
        let mut i = 0x01;
        while i & 0xff != 0 {
            bit = crc & 0x8000000000000000;
            if c & i != 0 {
                bit = !bit;
            }

            crc <<= 1;
            if bit != 0 {
                crc ^= POLY;
            }
            i <<= 1
        }

        crc &= 0xffffffffffffffff;
    }

    crc = crc & 0xffffffffffffffff;
    return crc_reflect(crc, 64) ^ 0x0000000000000000;
}

pub fn crc64_init() {
    let mut table = CRC64_TABLE.lock().unwrap();
    crcspeed64native_init(_crc64, &mut table);
}